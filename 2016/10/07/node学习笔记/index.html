<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Node学习笔记 · 金缮的随笔</title><meta name="description" content="Node学习笔记 - 晓松"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="yexiaosong.github.io/atom.xml" title="金缮的随笔"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="金缮的随笔" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">金缮的随笔</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于</p></a><ul class="shortcut-icons"><a href="https://github.com/yexiaosong" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="https://www.zhihu.com/people/yexiaosong" target="_blank"><img src="/images/zhihu.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Node学习笔记</h1><div class="post-info">2016年10月7日</div><div class="post-content"><h1 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h1><ul>
<li>es6的新属性<ul>
<li>let , const定义变量。let声明的代码值在块作用域里有效，同时不会有变量提升。</li>
<li>=&gt;箭头式函数，可以不改变this指针。</li>
<li>es6有块级作用域</li>
<li>模板字符串，使用两个反引号包起来。``里面可以有回车，换行等。</li>
</ul>
</li>
<li>异步非堵塞的相关知识</li>
<li>正则表达式<ul>
<li>match函数，stringObj.match(regExp)。有则返回注释部分，没有则返回null。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">'aabbccdd'</span>;</span><br><span class="line"><span class="keyword">var</span> res=str.match(<span class="regexp">/aa/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">//res输出为['aa',index:0,input:'aabbccdd'];</span></span><br></pre></td></tr></table></figure></li>
<li>exec函数,regExp.exec(stringObj)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'aabbccdd'</span>;</span><br><span class="line"><span class="keyword">var</span> res = <span class="regexp">/aa/</span>.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//res输出为['aa',index:0,input:'aabbccdd'];</span></span><br></pre></td></tr></table></figure></li>
<li>test函数，regExp.test(str).</li>
<li>search函数，stringObj.search(regExp)</li>
<li>replace函数，stringObj.search(regExp,replaceTest)</li>
<li>split函数，stringObj.split([separator[,limit]]);separator表示分隔符，可以为符号或正则表达式。<br>limit表示限制数组返回的个数。<h2 id="exec函数和match函数的区别："><a href="#exec函数和match函数的区别：" class="headerlink" title="exec函数和match函数的区别："></a>exec函数和match函数的区别：</h2></li>
</ul>
</li>
<li>方法所有者不同，match属于string，exec属于regaExp</li>
<li>match返回值：如果没有使用g(全局匹配)选项，则返回第一个匹配的字符串、<br>该字符串所在位置及原始字符串组成的数组，如果使用g选项，则返回所有匹配的字符串组成的数组</li>
<li>exec返回值：无论有无g选项，都返回第一个匹配的字符串、该字符串所在位置及原始字符串组成<br>的数组，但是该方法可以返回子匹配项，是match所不能及的</li>
</ul>
<h1 id="node-js基本概念"><a href="#node-js基本概念" class="headerlink" title="node.js基本概念"></a>node.js基本概念</h1><h2 id="REPL-交互式解释器read-eval-print-loop"><a href="#REPL-交互式解释器read-eval-print-loop" class="headerlink" title="REPL (交互式解释器read eval print loop)"></a>REPL (交互式解释器read eval print loop)</h2><ul>
<li>_下划线表示获取上一表达式的值。</li>
<li>.help表示列出使用命令<h2 id="命令行实质（argv）"><a href="#命令行实质（argv）" class="headerlink" title="命令行实质（argv）"></a>命令行实质（argv）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = process.argv.slice(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"init"</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'you are init a command'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'what is your meaning'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看出，argv就是你输入的命令并将其以数组方式存放。<h2 id="标准输入输出（stdin-stdout）"><a href="#标准输入输出（stdin-stdout）" class="headerlink" title="标准输入输出（stdin stdout）"></a>标准输入输出（stdin stdout）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'data'</span>, (input) =&gt; &#123;</span><br><span class="line">    input = input.toString().trim();</span><br><span class="line">    process.stdout.write(input + <span class="string">'nihao'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="基本API使用"><a href="#基本API使用" class="headerlink" title="基本API使用"></a>基本API使用</h1><h2 id="node-模块加载顺序，以require-some-module-时的加载顺序"><a href="#node-模块加载顺序，以require-some-module-时的加载顺序" class="headerlink" title="node 模块加载顺序，以require(some_module)时的加载顺序"></a>node 模块加载顺序，以require(some_module)时的加载顺序</h2><ol>
<li>如果是node的核心模块，找到后结束。</li>
<li>如果some_module以”./“, “/“, “../“时，按路径加载模块，结束。</li>
<li>如果当前目录为current_dir,  按路径加载 current_dir/node_modules/some_module<ul>
<li>加载成功，结束。</li>
<li>加载失败，令current_dir为其父目录，继续加载。</li>
<li>重复加载，直到根目录，抛出异常，结束。</li>
</ul>
</li>
</ol>
<h2 id="fs模块与path模块"><a href="#fs模块与path模块" class="headerlink" title="fs模块与path模块"></a>fs模块与path模块</h2><ul>
<li>fs.readFile<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">+ path</span></span><br><span class="line"><span class="string"> - path.join(__dirname,'..','a','b.txt): 拼接路径，非常常用。</span></span><br><span class="line"><span class="string"> - path.basename('a/b/c.txt): 获取路径中的文件名</span></span><br><span class="line"><span class="string"> - 小实例详询API</span></span><br><span class="line"><span class="string">+ 综合应用</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">//将文件加载到流中，并在控制台中打印</span></span><br><span class="line"><span class="keyword">const</span> buffer = fs.readFileSync(path.join(__dirname, <span class="string">'./haha/lrc.txt'</span>));</span><br><span class="line"><span class="keyword">const</span> content = buffer.toString();</span><br><span class="line"><span class="built_in">console</span>.log(content);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>但是发现当文本文件为gbk编码时，打印乱码。所以使用第三方库iconv，如下问题解决。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buffer = fs.readFileSync(path.join(__dirname, <span class="string">'./haha/lrc.txt'</span>));</span><br><span class="line"><span class="keyword">var</span> content = iconv.decode(buffer, <span class="string">'gbk'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(content);</span><br></pre></td></tr></table></figure></li>
<li>以流的方式，使用iconv库采用pipe方法，同时使用readline综合实现读取文档<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>);</span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(path.join(__dirname, <span class="string">'./a.txt'</span>));</span><br><span class="line">stream = stream.pipe(iconv.decodeStream(<span class="string">'GBK'</span>));</span><br><span class="line"><span class="keyword">const</span> rl = readline.createInterface(&#123;</span><br><span class="line">    input: stream,</span><br><span class="line">   <span class="comment">// output: process.stdout</span></span><br><span class="line">&#125;);</span><br><span class="line">rl.on(<span class="string">'line'</span>, (line) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`received: <span class="subst">$&#123;line&#125;</span> \n`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h2><h3 id="1-events对象中只提供一个对象，events-EventEmitter。它的核心就是事件的封装和触发。"><a href="#1-events对象中只提供一个对象，events-EventEmitter。它的核心就是事件的封装和触发。" class="headerlink" title="1.events对象中只提供一个对象，events.EventEmitter。它的核心就是事件的封装和触发。"></a>1.events对象中只提供一个对象，events.EventEmitter。它的核心就是事件的封装和触发。</h3><h3 id="2-events对象经典方式实现事件绑定及触发。（不合理）"><a href="#2-events对象经典方式实现事件绑定及触发。（不合理）" class="headerlink" title="2.events对象经典方式实现事件绑定及触发。（不合理）"></a>2.events对象经典方式实现事件绑定及触发。（不合理）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter; </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter(); </span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span>); </span><br><span class="line">&#125;); </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	event.emit(<span class="string">'some_event'</span>); </span><br><span class="line">&#125;, <span class="number">1000</span>); </span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">### 3.events对象es6新语法实现事件绑定及触发。（合理）</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">const</span> EventEmitter=<span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter=<span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>,()=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'woca'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h3 id="events常见的方法及描述"><a href="#events常见的方法及描述" class="headerlink" title="events常见的方法及描述"></a>events常见的方法及描述</h3><ul>
<li>addListener(event,listener);给制定监听器添加一个监听到时间尾部。</li>
<li>once(event,listener); 给事件注册一个最多执行一次的监听器</li>
<li>removeListener(event,listener);</li>
<li>removeAllListener(event,listener);</li>
<li>setMaxListener(int);在监听事件过多时会出现错误，通过此方法实现最大值设置。</li>
<li>emit(event,[arg1],[arg2],[…]);按顺序执行每个监听器。<h2 id="stream流"><a href="#stream流" class="headerlink" title="stream流"></a>stream流</h2><h3 id="四种流的类型"><a href="#四种流的类型" class="headerlink" title="四种流的类型"></a>四种流的类型</h3></li>
<li>Readable</li>
<li>Writable</li>
<li>Duplex</li>
<li>Transform<h3 id="所有的Stream对象都是EventEmitter对象的实例"><a href="#所有的Stream对象都是EventEmitter对象的实例" class="headerlink" title="所有的Stream对象都是EventEmitter对象的实例"></a>所有的Stream对象都是EventEmitter对象的实例</h3></li>
<li>data—当有数据可读时触发</li>
<li>end—-没数据可读时触发</li>
<li>error–错误时触发</li>
<li>finish-结束时触发<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"><span class="comment">// 设置编码为 utf8。</span></span><br><span class="line">readerStream.setEncoding(<span class="string">'UTF8'</span>);</span><br><span class="line"><span class="comment">// 处理流事件 --&gt; data, end, and error</span></span><br><span class="line">readerStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">   data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line">readerStream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">readerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="pipe-非常好用的管道流"><a href="#pipe-非常好用的管道流" class="headerlink" title="pipe,非常好用的管道流"></a>pipe,非常好用的管道流</h3></li>
</ul>
</li>
</ul>
<ul>
<li>基本使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> readStream=fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"><span class="keyword">var</span> writerStream=fs.createReadStream(<span class="string">'output.txt'</span>);</span><br><span class="line">readStream.pipe(writerStream);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure></li>
<li>pipe同事支持链式编程。</li>
</ul>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2017/01/09/redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/" class="prev">上一篇</a></div><div class="copyright"><p>© 2017 - 2021 <a href="yexiaosong.github.io">晓松</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>