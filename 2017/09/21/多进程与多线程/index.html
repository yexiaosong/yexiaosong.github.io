<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 多进程与多线程 · 金缮的随笔</title><meta name="description" content="多进程与多线程 - 晓松"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="yexiaosong.github.io/atom.xml" title="金缮的随笔"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="金缮的随笔" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">金缮的随笔</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于</p></a><ul class="shortcut-icons"><a href="https://github.com/yexiaosong" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="https://www.zhihu.com/people/yexiaosong" target="_blank"><img src="/images/zhihu.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">多进程与多线程</h1><div class="post-info">2017年9月21日</div><div class="post-content"><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>在linux系统中，0号进程为切换各进程的进程，并简介调用了1号进程，创建了系统。在使用多进程时，如果父进程先结束，子进程还没结束，则需要1号进程清理。</p>
<h3 id="类UNIX系统"><a href="#类UNIX系统" class="headerlink" title="类UNIX系统"></a>类UNIX系统</h3><p>在类UNIX操作系统中，可以引入os库，里面有fork方法。当pid为0时，则为子进程。而且此方法返回两个值，一个父进程号，另一个子0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'----子进程-----'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'---父进程---'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="跨平台方式"><a href="#跨平台方式" class="headerlink" title="跨平台方式"></a>跨平台方式</h3><p>引入multiprocessing模块中的Process方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"---test---"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p = Process(target = test)</span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'---main---'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>运行程序后会出现main和test交替出现的情况–即多线程。在上述代码中，Process最少接受一个参数，为target，表示子进程运行哪个代码段。其中process与使用fork函数的不同之处在于：fork的子进程和主进程可以不同时存在，即父进程死后子进程依旧可以运行。而使用process创建的进程在父进程死掉后，子进程会挂掉。换句话说，父进程一直等待所有的子进程。</p>
<ul>
<li>join() 此方法表示等到标记的进程都结束后才继续往下走，如果函数中传入了参数，则相当于等待一段时间后才实现。类似于setTimeout</li>
<li>terminate() 终止子进程</li>
</ul>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>进程池相当于缓冲，它先开几个进程，当你需要使用时调用即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"---pid = %d---"</span>%os.getpid())</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">3</span>) <span class="comment">#指定进程数，最多三个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    pool.apply_async(worker) <span class="comment">#向进程池中添加任务，非堵塞方式,堵塞方式没有什么意义</span></span><br><span class="line"></span><br><span class="line">pool.close() <span class="comment"># 关闭进程池，不能再次添加新任务</span></span><br><span class="line">pool.join() <span class="comment"># 主进程  执行了任务后，不会一直等到所有任务都完成才结束，主进程任务完成就推出。如果没有join，则进程池中的任务不会执行。</span></span><br></pre></td></tr></table></figure>
<h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><p>使用Queue, 类似的有vuex。Queue为堵塞的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line">q = Queue(<span class="number">3</span>)</span><br><span class="line">q.qsize() <span class="comment">#---&gt;0</span></span><br><span class="line">q.put(<span class="string">'num1'</span>)</span><br><span class="line">q.qsize() <span class="comment">#---&gt;1</span></span><br><span class="line">q.get() <span class="comment">#---&gt;num1</span></span><br><span class="line">q.get_nowait()<span class="comment"># ---&gt;如果使用get则会堵塞，但是使用get_nowait则会发生异常，以为强行取值。</span></span><br></pre></td></tr></table></figure>
<p>由上面代码知道在进行get之前需要先使用qsize()。<br>但是上面的代码只适用于通过processing创建出的多任务，不适合通过pool创建出的多任务。若要使用进程池，则如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line">q = Manager().Queue()</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>通常父线程等待子线程结束再结束。</li>
<li>线程之间共享全局变量，不会和进程一样单独的作用域<h3 id="使用类似Process创建多进程的方式"><a href="#使用类似Process创建多进程的方式" class="headerlink" title="使用类似Process创建多进程的方式"></a>使用类似Process创建多进程的方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">imort time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'----thread----'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = Thread(target = test)</span><br><span class="line">    t.start() <span class="comment">#---&gt;类似于multiprocessing 中的Process</span></span><br></pre></td></tr></table></figure>
<h3 id="使用类对多线程进行封装"><a href="#使用类对多线程进行封装" class="headerlink" title="使用类对多线程进行封装"></a>使用类对多线程进行封装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            msg = <span class="string">'THIS IS'</span> + self.name + <span class="string">'@'</span> + str(i)</span><br><span class="line">            print(msg)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3>为了解决共享变量出现的bug，出现了互斥锁。(全局变量是公用的，局部变量是独立的)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line">mutex = Lock() <span class="comment">#创建一个默认开着的锁</span></span><br><span class="line">mutex.acquire([blocking]) <span class="comment">#加锁</span></span><br><span class="line">mutex.release() <span class="comment">#释放锁</span></span><br></pre></td></tr></table></figure>
具体使用方式如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">py_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc_num1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> py_num</span><br><span class="line">    mutex.acquire() <span class="comment">#此锁锁定时，inc_num2堵塞</span></span><br><span class="line">    <span class="keyword">for</span> i i range(<span class="number">999999</span>):</span><br><span class="line">        py_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line">    print(<span class="string">'py_num is %d'</span>%py_num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc_num2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> py_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i i range(<span class="number">999999</span>):</span><br><span class="line">        py_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line">    print(<span class="string">'py_num2 is %d'</span>%py_num)</span><br><span class="line"></span><br><span class="line">mutex = Lock()</span><br><span class="line">p1 = Thread(target = inc_num1)</span><br><span class="line">p1.start()</span><br><span class="line">p2 = Thread(target = inc_num2)</span><br><span class="line">p2.start()</span><br></pre></td></tr></table></figure>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3>互相锁住，使用blocking处理</li>
</ul>
<h3 id="python多线程是假的"><a href="#python多线程是假的" class="headerlink" title="python多线程是假的"></a>python多线程是假的</h3><p>在python中，多核多线程是假的，因为存在GIL锁，此时想要彻底使用多线程可以调用其它语言。</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2017/09/28/python-%E7%BD%91%E7%BB%9C/" class="prev">上一篇</a><a href="/2017/09/16/python%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B92/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2020 <a href="yexiaosong.github.io">晓松</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>